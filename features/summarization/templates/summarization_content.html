<!-- features/summarization/templates/summarization_content.html -->

{# Check if this is an HTMX request specifically for the TEXT summary result #}
{% if request.headers.get('HX-Request') and hx_target_is_text_summary_result %}
    {# --- This block is ONLY for HTMX swapping the TEXT summary result --- #}
    {% if summary and not summary.startswith("(") %} {# Check if summary is not an error/info message #}
        <h2>Summary:</h2> 
        <div id="summary-output-container" class="summary-display-box">
            <!-- Content will be rendered by JS -->
        </div>
        {% if classification_used and classification_used != "N/A" %}
               {% if classification_used and classification_used != "N/A" %}
        <div class="model-used-info">
            <i class="fas fa-microchip"></i> Summary generated by AI Agent for: <strong>{{ classification_used }}</strong>
        </div>
        {% endif %}
        {% endif %}
        <script>
            (function() {
                const summaryContent = {{ summary|tojson }};
                const container = document.getElementById('summary-output-container');
                if (container && typeof window.renderMarkdownSummary === 'function') { // Check if function is on window
                    window.renderMarkdownSummary(summaryContent, container);
                } else if (container) { 
                    console.warn("renderMarkdownSummary function not found during HTMX swap, using basic render.");
                    container.innerHTML = '<p>' + summaryContent.replace(/\n/g, '<br>') + '</p>';
                }
            })();
        </script>
    {% elif summary %} {# Handles cases where summary is an error message from backend starting with ( #}
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if not messages %} {# If no flashed messages, but summary is an error message like (Error...) #}
                <div class="message-item category-error" role="alert">
                    <i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>
                    {{ summary }}
                </div>
            {% endif %}
        {% endwith %}
        {% if get_flashed_messages(with_categories=true) %} {# Display flashed messages if any #}
            {% with messages = get_flashed_messages(with_categories=true) %}
                {% for category, message in messages %}
                    <div class="message-item category-{{ category|default('info') }}" role="alert">
                        {% if category == 'error' %}<i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>
                        {% elif category == 'success' %}<i class="fas fa-check-circle" style="margin-right: 8px;"></i>
                        {% elif category == 'warning' %}<i class="fas fa-exclamation-circle" style="margin-right: 8px;"></i>
                        {% else %}<i class="fas fa-info-circle" style="margin-right: 8px;"></i>
                        {% endif %}
                        {{ message }}
                    </div>
                {% endfor %}
            {% endwith %}
        {% endif %}
    {% elif get_flashed_messages(with_categories=true) %} {# Standard flashed messages display #}
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% for category, message in messages %}
                <div class="message-item category-{{ category|default('info') }}" role="alert">
                    {% if category == 'error' %}<i class="fas fa-exclamation-triangle" style="margin-right: 8px;"></i>
                    {% elif category == 'success' %}<i class="fas fa-check-circle" style="margin-right: 8px;"></i>
                    {% elif category == 'warning' %}<i class="fas fa-exclamation-circle" style="margin-right: 8px;"></i>
                    {% else %}<i class="fas fa-info-circle" style="margin-right: 8px;"></i>
                    {% endif %}
                    {{ message }}
                </div>
            {% endfor %}
        {% endwith %}
    {% else %}
        <p><i>No text summary generated yet or an issue occurred.</i></p>
    {% endif %}
{% elif request.headers.get('HX-Request') and hx_target_is_ppt_status_result %}
    {# --- This block is for HTMX swapping PPT status --- #}
    {% if ppt_error_message %}
        <div id="ppt-builder-status" class="ppt-builder-error">{{ ppt_error_message }}</div>
    {% elif ppt_success_message and ppt_download_url %}
        <div id="ppt-builder-status" class="ppt-builder-success">
            {{ ppt_success_message }}
            <br>
            <a href="{{ ppt_download_url }}" id="download-btn" class="submit-button" style="margin-top: 1rem; display: inline-block; width: auto;">Download Presentation</a>
        </div>
    {% elif get_flashed_messages(with_categories=true) %}
         {% with messages = get_flashed_messages(with_categories=true) %}
            {% for category, message in messages %}
                <div class="message-item category-{{ category|default('info') }}" role="alert">
                     {{ message }}
                </div>
            {% endfor %}
        {% endwith %}
    {% else %}
        <p><i>PPT generation status updates might appear here if configured for HTMX.</i></p>
    {% endif %}
{% else %}
    {# --- This is the FULL initial rendering of the feature --- #}
    <div class="feature-container summarization-tile-container">
        <h1><i class="fas fa-file-alt"></i> Intelligent Document Summarization</h1>

        <div class="feature-tabs">
            <button class="tab-link active" data-target-tab="text-summary-tab">
                <i class="fas fa-align-left"></i> Create Text Summary
            </button>
            <button class="tab-link" data-target-tab="ppt-summary-tab">
                <i class="fas fa-file-powerpoint"></i> Create Executive PowerPoint
            </button>
        </div>

        <!-- Tab Content for Text Summary -->
        <div id="text-summary-tab" class="feature-tab-content active-content">
            <div class="feature-explanation" style="margin-top:15px;">
                <p>This service leverages <strong>advanced Artificial Intelligence</strong> to deliver highly accurate and nuanced summaries, meticulously tailored to the specific type of document you provide. Our sophisticated two-step process ensures you receive the most relevant insights:</p>
                <ol style="margin-top: 1rem; margin-bottom: 1rem; padding-left: 1.5rem;">
                    <li style="margin-bottom: 0.75rem;">
                        <strong>Intelligent Document Classification:</strong>
                        <p style="margin-top: 0.25rem; margin-bottom: 0.25rem;">
                            Our system first automatically identifies the nature of your document – be it a legal contract, financial report, technical manual, or marketing plan. This AI-powered analysis goes beyond simple keywords, understanding the unique structure and language of various document categories. This foundational step is crucial for applying the most effective summarization strategy, ensuring relevance from the outset.
                        </p>
                    </li>
                    <li>
                        <strong>Context-Aware Summarization with Specialized AI Models:</strong>
                        <p style="margin-top: 0.25rem; margin-bottom: 0.5rem;">
                            Once classified, your document is processed by one of our <strong>20+ Specialized AI Models</strong>. These are custom-tuned AI engines, each an expert in extracting critical information from specific document types. For instance:
                        </p>
                        <ul style="margin-left: 1.25rem; margin-bottom: 0.5rem; list-style-type: disc;">
                            <li style="margin-bottom: 0.25rem;">Our <em>Financial Report Model</em> pinpoints key financial figures, performance trends, and executive outlooks.</li>
                            <li style="margin-bottom: 0.25rem;">The <em>Legal Contract Model</em> focuses on obligations, critical clauses, and potential risks.</li>
                            <li>A <em>Technical Document Model</em> highlights core functionalities, setup procedures, and troubleshooting advice.</li>
                        </ul>
                        <p style="margin-bottom: 0.25rem;">
                            This bespoke approach ensures your summary is not a mere truncation, but a targeted extraction of the information that truly matters for that document's purpose, delivering precision and depth.
                        </p>
                    </li>
                </ol>
                <p>This intelligent, type-specific methodology, powered by our comprehensive suite of specialized AI models, delivers unparalleled insight. It transforms lengthy documents into actionable intelligence, quickly and efficiently – like having a team of expert analysts available on demand to distill complex information into its essential components.</p>
            </div>
            <form id="text-summary-form" hx-post="{{ url_for('process_summarize') }}" hx-target="#text-summarization-result" hx-swap="innerHTML" enctype="multipart/form-data" hx-indicator="#text-summary-form .spinner">
                <div class="form-group">
                    <label for="text-summary-file-input" id="text-summary-drop-zone-label" class="drop-zone-style"
                           style="display: block; border: 2px dashed #007bff; padding: 20px; text-align: center; cursor: pointer; background-color: #f8f9fa; border-radius: 5px; margin-bottom: 10px;">
                        <p style="margin:0 0 5px 0; font-size: 1.0em; color: #333;">Drop .docx, .pptx, .xlsx, or .pdf file here (max 10MB), or click to select.</p>
                        <p id="text-summary-file-name-display" style="margin-top:5px; font-weight: bold; color: #555;">No file selected</p>
                    </label>
                    <input type="file" id="text-summary-file-input" name="file" accept=".docx,.pptx,.xlsx,.pdf"
                           style="position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;">
                </div>
                <button type="submit" class="submit-button">
                    <i class="fas fa-file-alt"></i> Summarize Text
                    <span class="htmx-indicator spinner"></span>
                </button>
            </form>
            <div id="text-summarization-result" class="processing-result">
                 {# Initial state for full page load, summary and classification_used would be None #}
                 {% if summary and not summary.startswith("(") %}
                    <h2>Summary:</h2>
                    <div id="summary-output-container" class="summary-display-box">
                         <!-- JS will populate this -->
                    </div>
                    {% if classification_used and classification_used != "N/A" %}
                    <div class="model-used-info">
                        <i class="fas fa-microchip"></i> This summary was refined using our Specialized AI Model for <strong>{{ classification_used }}</strong> documents.
                    </div>
                    {% endif %}
                    <script>
                        (function() {
                            const summaryContent = {{ summary|tojson }};
                            const container = document.getElementById('summary-output-container');
                            if (container && typeof window.renderMarkdownSummary === 'function') { // Check if function is on window
                                window.renderMarkdownSummary(summaryContent, container);
                            } else if (container) {
                                 console.warn("renderMarkdownSummary function not found on initial load, using basic render.");
                                container.innerHTML = '<p>' + summaryContent.replace(/\n/g, '<br>') + '</p>';
                            }
                        })();
                    </script>
                {% else %}
                    <p><i>Text summary will appear here.</i></p>
                {% endif %}
            </div>
        </div>

        <!-- Tab Content for PPT Summary -->
        <div id="ppt-summary-tab" class="feature-tab-content">
            <h2>Generate an Executive PowerPoint Summary</h2>
            <div class="feature-explanation" style="margin-top:15px;">
                 <p>
                    This tool creates executive-level PowerPoint presentations from your uploaded documents (e.g., Word, PDF, Python code).
                    It uses a multi-step AI process. Default presentation style will be used.
                </p>
            </div>

            {% if not ppt_api_key_configured %}
            <div class="ppt-builder-api-warning">
                <strong>Configuration Notice:</strong> {% if ppt_config_warning %}{{ ppt_config_warning }}{% else %}Core AI or Storage services may be unavailable. Presentation generation might fail.{% endif %}
            </div>
            {% endif %}

            <form id="ppt-builder-upload-form" method="POST" enctype="multipart/form-data"
                  hx-post="{{ url_for('process_create_ppt') }}"
                  hx-target="#ppt-builder-status-container" 
                  hx-swap="innerHTML"
                  enctype="multipart/form-data"
                  hx-indicator="#ppt-builder-convert-btn"> 

                <input type="hidden" name="template" value="{{ ppt_default_template | default('professional') }}">
                <input type="hidden" name="inputType" value="file">

                <div class="ppt-builder-step-section">
                    <div id="ppt-builder-file-upload-section">
                         <label for="ppt-builder-file-input" id="ppt-builder-drop-zone-label" class="drop-zone-style {% if not ppt_api_key_configured %}disabled-drop-zone{% endif %}">
                             <p>
                                 Source Files ({{ ppt_allowed_extensions_str|default('.docx, .pdf, or .py') }}, up to {{ ppt_max_files|default(5) }} files, max {{ ppt_max_file_size_mb|default(10) }}MB each)
                             </p>
                             <p>Drag & drop your file(s) here or click to select.</p>
                             <div id="ppt-builder-file-info"><p class="ppt-builder-no-files-msg">No files selected.</p></div>
                         </label>
                         <input type="file" id="ppt-builder-file-input" name="file" accept="{{ ppt_allowed_extensions_str|default('.docx,.pdf,.py') }}"
                                style="position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;" multiple
                                {% if not ppt_api_key_configured %}disabled{% endif %}>
                    </div>
                </div>

                <button type="submit" id="ppt-builder-convert-btn" class="submit-button" {% if not ppt_api_key_configured %}disabled{% endif %}>
                    <i class="fas fa-magic"></i> Generate Presentation
                    <span class="spinner htmx-indicator"></span> 
                </button>
            </form>

            <div id="ppt-builder-status-container" class="processing-result" style="min-height: 50px;">
                <div id="ppt-builder-status">
                    <p><i>PowerPoint generation status and download link will appear here.</i></p>
                </div>
            </div>
        </div> <!-- End of ppt-summary-tab -->

    </div> {# End of summarization-tile-container #}

    <script>
    // Self-invoking function to scope all JS for this feature
    (function() {
        const summarizationFeatureContainer = document.querySelector('.summarization-tile-container');
        if (!summarizationFeatureContainer) {
            return;
        }

        // --- Markdown Renderer for Text Summary (ensure this is defined once and accessible) ---
        // Hoist function definition to be accessible throughout the IIFE scope
        function renderMarkdownSummary(markdownText, containerElement) {
            if (!markdownText || markdownText.trim() === "") {
                containerElement.innerHTML = '<p><i>No summary content to display.</i></p>';
                return;
            }

            let html = "";
            const lines = markdownText.split('\n');
            let inList = false;
            let currentParagraph = "";

            function flushParagraph() {
                if (currentParagraph.trim() !== "") {
                    currentParagraph = currentParagraph.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    html += `<p>${currentParagraph.trim()}</p>\n`;
                }
                currentParagraph = "";
            }

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const headingMatch = line.match(/^\s*\*\*(.+?)\:\*\*\s*$/);
                if (headingMatch) {
                    flushParagraph(); 
                    if (inList) { html += "</ul>\n"; inList = false; }
                    html += `<h4>${headingMatch[1].trim()}:</h4>\n`; 
                    continue;
                }
                const listItemMatch = line.match(/^\s*-\s+(.+)/);
                if (listItemMatch) {
                    flushParagraph(); 
                    if (!inList) { html += "<ul>\n"; inList = true; }
                    let listItemContent = listItemMatch[1];
                    listItemContent = listItemContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    html += `  <li>${listItemContent}</li>\n`;
                    continue;
                }
                if (inList) { // If it's not a list item and we were in a list, close the list.
                    html += "</ul>\n";
                    inList = false;
                }
                
                if (line.trim() !== "") {
                    currentParagraph += (currentParagraph === "" ? "" : " ") + line; 
                } else { 
                    flushParagraph();
                }
            }
            flushParagraph(); 
            if (inList) { html += "</ul>\n"; } 
            containerElement.innerHTML = html;
        }
        // Expose to window if not already there, useful for HTMX script blocks that might run in a different microtask
        if (typeof window.renderMarkdownSummary !== 'function') {
            window.renderMarkdownSummary = renderMarkdownSummary;
        }


        // --- Tab Switching Logic ---
        const tabLinks = summarizationFeatureContainer.querySelectorAll('.feature-tabs .tab-link');
        const tabContents = summarizationFeatureContainer.querySelectorAll('.feature-tab-content');
        function openSummarizationTab(targetTabId) {
            tabContents.forEach(tc => { tc.style.display = 'none'; tc.classList.remove('active-content'); });
            tabLinks.forEach(tl => tl.classList.remove('active'));
            const currentTabContent = summarizationFeatureContainer.querySelector('#' + targetTabId);
            const currentTabLink = summarizationFeatureContainer.querySelector(`.feature-tabs .tab-link[data-target-tab="${targetTabId}"]`);
            if (currentTabContent) { currentTabContent.style.display = 'block'; currentTabContent.classList.add('active-content'); }
            if (currentTabLink) { currentTabLink.classList.add('active'); }
        }
        tabLinks.forEach(link => {
            link.addEventListener('click', function(event) {
                event.preventDefault();
                const targetTabId = this.dataset.targetTab;
                if (targetTabId) { openSummarizationTab(targetTabId); }
            });
        });
        if (tabLinks.length > 0 && !summarizationFeatureContainer.querySelector('.feature-tabs .tab-link.active')) {
             const firstTabId = tabLinks[0].dataset.targetTab;
             if (firstTabId) openSummarizationTab(firstTabId);
        }

        // --- Text Summary Tab File Upload Logic ---
        const textSummaryDropZoneLabel = summarizationFeatureContainer.querySelector('#text-summary-drop-zone-label');
        const textSummaryFileInput = summarizationFeatureContainer.querySelector('#text-summary-file-input');
        const textSummaryFileNameDisplay = summarizationFeatureContainer.querySelector('#text-summary-file-name-display');
        const textSummaryForm = summarizationFeatureContainer.querySelector('#text-summary-form');
        const TEXT_SUMMARY_MAX_FILE_SIZE_MB = 10;
        const TEXT_SUMMARY_MAX_FILE_SIZE_BYTES = TEXT_SUMMARY_MAX_FILE_SIZE_MB * 1024 * 1024;

        if (textSummaryDropZoneLabel && textSummaryFileInput && textSummaryFileNameDisplay && textSummaryForm) {
            textSummaryDropZoneLabel.addEventListener('dragover', (e) => { e.preventDefault(); textSummaryDropZoneLabel.classList.add('drag-over'); textSummaryDropZoneLabel.style.borderColor = '#28a745'; });
            textSummaryDropZoneLabel.addEventListener('dragleave', () => { textSummaryDropZoneLabel.classList.remove('drag-over'); textSummaryDropZoneLabel.style.borderColor = '#007bff'; });
            
            function handleTextSummaryFileChange() {
                if (textSummaryFileInput.files.length > 0) {
                    const file = textSummaryFileInput.files[0];
                    if (file.size > TEXT_SUMMARY_MAX_FILE_SIZE_BYTES) {
                        alert(`File "${file.name}" is too large (${(file.size / 1024 / 1024).toFixed(2)}MB). Maximum size is ${TEXT_SUMMARY_MAX_FILE_SIZE_MB}MB.`);
                        textSummaryFileInput.value = ''; 
                        textSummaryFileNameDisplay.textContent = 'No file selected';
                        textSummaryDropZoneLabel.classList.remove('file-selected');
                        textSummaryDropZoneLabel.style.borderColor = '#007bff';
                        return;
                    }
                    textSummaryFileNameDisplay.textContent = file.name;
                    textSummaryDropZoneLabel.classList.add('file-selected');
                    textSummaryDropZoneLabel.style.borderColor = '#28a745';
                } else {
                    textSummaryFileNameDisplay.textContent = 'No file selected';
                    textSummaryDropZoneLabel.classList.remove('file-selected');
                    textSummaryDropZoneLabel.style.borderColor = '#007bff';
                }
            }

            textSummaryDropZoneLabel.addEventListener('drop', (e) => { 
                e.preventDefault(); 
                textSummaryDropZoneLabel.classList.remove('drag-over'); 
                textSummaryDropZoneLabel.style.borderColor = '#007bff'; 
                const files = e.dataTransfer.files; 
                if (files.length > 0) { 
                    textSummaryFileInput.files = files; 
                    handleTextSummaryFileChange(); 
                } 
            });
            textSummaryFileInput.addEventListener('change', handleTextSummaryFileChange); 
            
            textSummaryForm.addEventListener('submit', function(event) { 
                if (textSummaryFileInput.files.length === 0) { 
                    alert('Please upload a file to summarize.'); 
                    event.preventDefault(); 
                } 
            });
        }

        // --- SIMPLIFIED PPT Builder Specific JavaScript ---
        const pptBuilderForm = summarizationFeatureContainer.querySelector('#ppt-builder-upload-form');
        if (pptBuilderForm) {
            const pptDropZoneLabel = summarizationFeatureContainer.querySelector('#ppt-builder-drop-zone-label');
            const pptFileInput = summarizationFeatureContainer.querySelector('#ppt-builder-file-input');
            const pptConvertBtn = summarizationFeatureContainer.querySelector('#ppt-builder-convert-btn');
            const pptFileInfoDiv = summarizationFeatureContainer.querySelector('#ppt-builder-file-info');

            const pptApiKeyIsConfigured = {{ ppt_api_key_configured|default(false)|tojson }};
            const PPT_MAX_FILES = {{ ppt_max_files|default(5) }};
            const PPT_MAX_FILE_SIZE_MB = {{ ppt_max_file_size_mb|default(10) }};
            const PPT_MAX_FILE_SIZE = PPT_MAX_FILE_SIZE_MB * 1024 * 1024;
            const PPT_ALLOWED_EXTENSIONS_STR = "{{ ppt_allowed_extensions_str|default('.docx,.pdf,.py') }}";
            const PPT_ALLOWED_EXTENSIONS = PPT_ALLOWED_EXTENSIONS_STR.replace(/\./g, '').split(',').map(ext => ext.trim().toLowerCase());

            function updatePptConvertButtonState() {
                 if(!pptConvertBtn) return;
                 const isReady = pptFileInput && pptFileInput.files && pptFileInput.files.length > 0 && pptApiKeyIsConfigured;
                 pptConvertBtn.disabled = !isReady;
                 if (pptDropZoneLabel) {
                     if (!pptApiKeyIsConfigured) {
                          pptDropZoneLabel.classList.add('disabled-drop-zone');
                          pptDropZoneLabel.style.cursor = 'not-allowed';
                           const apiWarningDiv = summarizationFeatureContainer.querySelector('.ppt-builder-api-warning');
                           if (apiWarningDiv) {
                               pptDropZoneLabel.title = apiWarningDiv.textContent.trim() || 'Presentation generation service is currently unavailable.';
                           } else {
                               pptDropZoneLabel.title = 'Presentation generation service is currently unavailable.';
                           }
                     } else {
                          pptDropZoneLabel.classList.remove('disabled-drop-zone');
                          pptDropZoneLabel.style.cursor = 'pointer';
                          pptDropZoneLabel.title = ''; 
                     }
                     const isFileSelected = pptFileInput && pptFileInput.files && pptFileInput.files.length > 0;
                     if (!isFileSelected) {
                          pptDropZoneLabel.style.borderColor = !pptApiKeyIsConfigured ? '#ced4da' : '#007bff';
                     }
                 }
            }

            function displayPptFileInfo(fileList) {
                if (!pptFileInfoDiv || !pptFileInput) return; 
                pptFileInfoDiv.innerHTML = ''; 
                const files = pptFileInput.files; 
                if (files.length > 0) {
                    const p = document.createElement('p');
                    p.textContent = `Selected Files (${files.length}):`;
                    p.style.cssText = 'color: var(--text-color-primary); font-weight: bold; text-align: left; margin-bottom: 0.3rem;';
                    pptFileInfoDiv.appendChild(p);
                    let invalidCount = 0, typeErrorCount = 0, sizeErrorCount = 0;
                    const fileListElement = document.createElement('ul');
                    fileListElement.style.cssText = 'list-style-type: none; padding-left: 0; text-align: left;';
                    Array.from(files).forEach(file => {
                        const li = document.createElement('li');
                        const fileExt = file.name.split('.').pop()?.toLowerCase() || '';
                        let isTypeValid = PPT_ALLOWED_EXTENSIONS.includes(fileExt);
                        let isSizeValid = file.size <= PPT_MAX_FILE_SIZE;
                        let isValid = isTypeValid && isSizeValid;
                        li.textContent = `${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
                        li.style.cssText = 'font-size: 0.9em; margin-bottom: 0.2rem;';
                        if (!isValid) {
                            li.style.color = 'var(--error-message-color, #ef4444)';
                            li.textContent += ' (Invalid)'; 
                            invalidCount++;
                            if (!isTypeValid) typeErrorCount++;
                            if (!isSizeValid) sizeErrorCount++;
                        } else {
                            li.style.color = 'var(--text-color-secondary)'; 
                        }
                        fileListElement.appendChild(li);
                    });
                     pptFileInfoDiv.appendChild(fileListElement); 
                    if (invalidCount > 0) {
                        const pWarn = document.createElement('p');
                        pWarn.style.cssText = 'color: var(--error-message-color, #ef4444); font-size: 0.9em; margin-top: 0.5rem; text-align: left;';
                        let warnMsgParts = [];
                        if (typeErrorCount > 0) warnMsgParts.push(`invalid type (allowed: ${PPT_ALLOWED_EXTENSIONS.join(', ')})`);
                        if (sizeErrorCount > 0) warnMsgParts.push(`too large (max ${PPT_MAX_FILE_SIZE_MB}MB each)`);
                        if (files.length > PPT_MAX_FILES) { 
                             pWarn.textContent = `Too many files selected (${files.length}). Maximum allowed is ${PPT_MAX_FILES}.`;
                        } else if (warnMsgParts.length > 0) {
                             pWarn.textContent = `${invalidCount} file(s) ignored: ${warnMsgParts.join(' and ')}.`;
                        }
                        pptFileInfoDiv.appendChild(pWarn);
                    }
                } else {
                     pptFileInfoDiv.innerHTML = '<p class="ppt-builder-no-files-msg" style="font-weight:normal; color:#555;">No files selected.</p>';
                }
                 if (pptDropZoneLabel) {
                     const isFileSelected = files.length > 0;
                     if (isFileSelected) {
                         pptDropZoneLabel.classList.add('file-selected');
                         pptDropZoneLabel.style.borderColor = '#17a2b8'; 
                     } else {
                         pptDropZoneLabel.classList.remove('file-selected');
                         pptDropZoneLabel.style.borderColor = !pptApiKeyIsConfigured ? '#ced4da' : '#007bff';
                     }
                 }
            }
            
            function clearPptStatus() {
                const statusDiv = summarizationFeatureContainer.querySelector('#ppt-builder-status');
                if (statusDiv) {
                    statusDiv.innerHTML = '<p><i>PowerPoint generation status and download link will appear here.</i></p>';
                    statusDiv.className = ''; 
                }
            }

            function showPptStatus(message, type = 'info') { 
                const statusDiv = summarizationFeatureContainer.querySelector('#ppt-builder-status');
                if (statusDiv) {
                    statusDiv.innerHTML = `<p>${message}</p>`;
                    statusDiv.className = `ppt-builder-${type}`; 
                }
            }

            if(pptFileInput) {
                 pptFileInput.addEventListener('change', function(e) {
                    displayPptFileInfo(e.target.files); 
                    updatePptConvertButtonState(); 
                     clearPptStatus(); 
                 });
            }

            if(pptDropZoneLabel && pptFileInput) {
                pptDropZoneLabel.addEventListener('dragover', (e) => {
                    e.preventDefault(); 
                    if (!pptFileInput.disabled) { 
                       pptDropZoneLabel.classList.add('drag-over');
                       pptDropZoneLabel.style.borderColor = '#28a745'; 
                    }
                });
                ['dragleave', 'dragend'].forEach(type => pptDropZoneLabel.addEventListener(type, (e) => {
                    e.preventDefault(); 
                    if (!pptFileInput.disabled) { 
                        pptDropZoneLabel.classList.remove('drag-over');
                        const isFileSelected = pptFileInput.files && pptFileInput.files.length > 0;
                        pptDropZoneLabel.style.borderColor = isFileSelected ? '#17a2b8' : '#007bff';
                    }
                }));
                pptDropZoneLabel.addEventListener('drop', (e) => {
                    e.preventDefault(); 
                    if (!pptFileInput.disabled) { 
                        pptDropZoneLabel.classList.remove('drag-over');
                        const isFileSelected = pptFileInput.files && pptFileInput.files.length > 0; // Check before assigning new files
                        pptDropZoneLabel.style.borderColor = isFileSelected ? '#17a2b8' : '#007bff'; // Then update color based on current state before potential change

                        const files = e.dataTransfer.files; 
                        if (files.length > 0) {
                            pptFileInput.value = ''; 
                            pptFileInput.files = files; 
                            const event = new Event('change', { bubbles: true });
                            pptFileInput.dispatchEvent(event);
                        }
                    }
                });
                 pptDropZoneLabel.addEventListener('click', () => {
                     if (pptFileInput && !pptFileInput.disabled) {
                         // Label 'for' attribute handles this.
                     }
                 });
            }

            if(pptBuilderForm && pptFileInput) {
                 pptBuilderForm.addEventListener('htmx:submit', function(event) {
                    const files = pptFileInput.files;
                    let isValidSelection = true;
                    let validationMessage = '';
                    if (files.length === 0) {
                        isValidSelection = false;
                        validationMessage = 'Please select a file(s) to generate a presentation.';
                    } else if (files.length > PPT_MAX_FILES) {
                         isValidSelection = false;
                         validationMessage = `Too many files selected (${files.length}). Maximum allowed is ${PPT_MAX_FILES}.`;
                    } else {
                         Array.from(files).forEach(file => {
                             const fileExt = file.name.split('.').pop()?.toLowerCase() || '';
                             let isTypeValid = PPT_ALLOWED_EXTENSIONS.includes(fileExt);
                             let isSizeValid = file.size <= PPT_MAX_FILE_SIZE;
                             if (!isTypeValid || !isSizeValid) isValidSelection = false;
                         });
                         if (!isValidSelection && files.length <= PPT_MAX_FILES) {
                            validationMessage = `One or more selected files are invalid (check type or size). Allowed: ${PPT_ALLOWED_EXTENSIONS.join(', ')}, Max size: ${PPT_MAX_FILE_SIZE_MB}MB each.`;
                         }
                    }
                    if (!isValidSelection) {
                        alert(validationMessage || 'Invalid file selection.'); 
                        showPptStatus(validationMessage || 'Invalid file selection.', 'error'); 
                        event.preventDefault(); 
                    } else {
                        event.detail.formData.delete('file');
                        Array.from(files).forEach(file => {
                             event.detail.formData.append('file', file, file.name);
                        });
                    }
                 });
            }
            // Initial state setup
            setTimeout(() => {
                if (pptFileInput) displayPptFileInfo(pptFileInput.files);
                updatePptConvertButtonState();
                clearPptStatus();
            }, 50);

            summarizationFeatureContainer.addEventListener('openSummarizationTab', function(event) {
                 if (event.detail.targetTabId === 'ppt-summary-tab') {
                      setTimeout(() => {
                         if (pptFileInput) displayPptFileInfo(pptFileInput.files);
                         updatePptConvertButtonState();
                         clearPptStatus();
                      }, 50); 
                 }
             });
        } 
    })();
    </script>
{% endif %}